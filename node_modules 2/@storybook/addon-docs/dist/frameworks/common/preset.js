"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.constructor");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.webpack = webpack;
exports.managerEntries = managerEntries;
exports.config = config;

var _mdxCompilerPlugin = _interopRequireDefault(require("@storybook/addon-docs/mdx-compiler-plugin"));

var _path = _interopRequireDefault(require("path"));

var _remarkSlug = _interopRequireDefault(require("remark-slug"));

var _remarkExternalLinks = _interopRequireDefault(require("remark-external-links"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function createBabelOptions(babelOptions, configureJSX) {
  if (!configureJSX) {
    return babelOptions;
  }

  var babelPlugins = babelOptions && babelOptions.plugins || [];
  return Object.assign({}, babelOptions, {
    // for frameworks that are not working with react, we need to configure
    // the jsx to transpile mdx, for now there will be a flag for that
    // for more complex solutions we can find alone that we need to add '@babel/plugin-transform-react-jsx'
    plugins: [].concat(_toConsumableArray(babelPlugins), ['@babel/plugin-transform-react-jsx'])
  });
}

function webpack() {
  var webpackConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _webpackConfig$module = webpackConfig.module,
      module = _webpackConfig$module === void 0 ? {} : _webpackConfig$module; // it will reuse babel options that are already in use in storybook
  // also, these babel options are chained with other presets.

  var babelOptions = options.babelOptions,
      _options$configureJSX = options.configureJSX,
      configureJSX = _options$configureJSX === void 0 ? options.framework !== 'react' : _options$configureJSX,
      _options$sourceLoader = options.sourceLoaderOptions,
      sourceLoaderOptions = _options$sourceLoader === void 0 ? {} : _options$sourceLoader;
  var mdxLoaderOptions = {
    remarkPlugins: [_remarkSlug["default"], _remarkExternalLinks["default"]]
  }; // set `sourceLoaderOptions` to `null` to disable for manual configuration

  var sourceLoader = sourceLoaderOptions ? [{
    test: /\.(stories|story)\.[tj]sx?$/,
    loader: require.resolve('@storybook/source-loader'),
    options: Object.assign({}, sourceLoaderOptions, {
      inspectLocalDependencies: true
    }),
    enforce: 'pre'
  }] : [];
  var result = Object.assign({}, webpackConfig, {
    module: Object.assign({}, module, {
      rules: [].concat(_toConsumableArray(module.rules || []), [{
        test: /\.js$/,
        include: new RegExp("node_modules\\".concat(_path["default"].sep, "acorn-jsx")),
        use: [{
          loader: 'babel-loader',
          options: {
            presets: [[require.resolve('@babel/preset-env'), {
              modules: 'commonjs'
            }]]
          }
        }]
      }, {
        test: /\.(stories|story).mdx$/,
        use: [{
          loader: 'babel-loader',
          options: createBabelOptions(babelOptions, configureJSX)
        }, {
          loader: '@mdx-js/loader',
          options: Object.assign({
            compilers: [(0, _mdxCompilerPlugin["default"])(options)]
          }, mdxLoaderOptions)
        }]
      }, {
        test: /\.mdx$/,
        exclude: /\.(stories|story).mdx$/,
        use: [{
          loader: 'babel-loader',
          options: createBabelOptions(babelOptions, configureJSX)
        }, {
          loader: '@mdx-js/loader',
          options: mdxLoaderOptions
        }]
      }], sourceLoader)
    })
  });
  return result;
}

function managerEntries() {
  var entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var options = arguments.length > 1 ? arguments[1] : undefined;
  return [].concat(_toConsumableArray(entry), [require.resolve('../../register')]);
}

function config() {
  var entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var framework = options.framework;
  var docsConfig = [require.resolve('./config')];

  try {
    docsConfig.push(require.resolve("../".concat(framework, "/config")));
  } catch (err) {// there is no custom config for the user's framework, do nothing
  }

  return [].concat(docsConfig, _toConsumableArray(entry));
}